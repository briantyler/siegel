/*
 * ### autorights BEGIN ###
 * siegel / siegelcl is an application that computes Siegel sets and cusp
 * lists for the action of SU(n,1;O) on HCn. Its development was supported
 * by EPSRC and University College London.
 * 
 * Copyright (C) 2009  Brian Tyler
 * 
 * This program is free software: you can redistribute it and/or modify
 * it under the terms of the GNU General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 * 
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>.
 * ### autorights END ###
 */

/**
 *  @file     point_phi.hpp
 *  @brief    An inline header file for the \c point_phi class.
 *  @note     Computes the maximum height attainable by the action of a cusp on
 *            a hypercube interpreted by a point.
 *  @author   Brian Tyler
 *  @version  1.0
 *  @date     2008-06-03
 */


#ifndef _SG_POINT_PHI_H
#define _SG_POINT_PHI_H 1

// Global includes
#include <functional>
#include <cmath>
#include <utility>

#include <boost/call_traits.hpp>
#include <boost/mpl/assert.hpp>
#include <boost/type_traits/is_same.hpp>

// Local includes
#include "utility/math/hermitian_inner_product.hpp"
#include "utility/math/is_zero.hpp"


namespace sg
{
namespace geometry
{
namespace effect
{
/**
 *  @class    point_phi
 *  @brief    Computes the maximum height attainable by the action of a cusp on
 *            a hypercube.
 *  @author   Brian Tyler
 *  @version  1.0
 *  @date     2008-03-20
 *  @param    Point The hyperbolic point type
 *  @param    Slice The type of the heisenberg slice
 *  @param    Cusp The cusp type
 */
template <class _Point, class _Slice, class _Cusp> class point_phi
: public std::binary_function< const _Point&,
                               const _Cusp&,
                               typename _Cusp::float_type>
{
  // Ensure the floating point types are the same at compile time
  BOOST_MPL_ASSERT(( boost::is_same< typename _Point::float_type,
                                     typename _Slice::float_type >
                   ));
  BOOST_MPL_ASSERT(( boost::is_same< typename _Point::float_type,
                                     typename _Cusp::float_type >
                   ));
  
  // Ensure the hyperbolic dimensions are equal at compile time
  BOOST_MPL_ASSERT_RELATION(  _Point::dimension_size,
                              ==,
                              _Slice::dimension_size
                            );
  BOOST_MPL_ASSERT_RELATION(  _Point::dimension_size,
                              ==,
                              _Cusp::dimension_size
                            );
  
  
  public:
    //! The object type
    typedef point_phi<_Point,_Slice,_Cusp> self_type;
    //! The hyperbolic point type
    typedef _Point point_type;
    //! The heisenberg slice type
    typedef _Slice slice_type;
    //! The Cusp type
    typedef _Cusp cusp_type;
    //! The floating point type
    typedef typename cusp_type::float_type float_type;
    //! The complex type
    typedef typename cusp_type::complex_type complex_type;
    
  private:
    //! Floating point param type
    typedef typename boost::call_traits<float_type>::param_type param_type;
    //! The internal retrurn type
    typedef std::pair<float_type, float_type> ff_pair_type;
    
  public:
    /**
     *  @brief  Slice constructor
     *  @param  slice The slice in which the points exist.
     *  @note   The slice determines the size of hypercubes in the space.
     */
    point_phi( const slice_type& __slice ) : slice_( &__slice ) { }
    
    
    /**
     *  @brief  Computes the phi function of a cusp at a point.
     *  @param  point The first vertex of a hypercube.
     *  @param  cusp A cusp on the boundary.
     *  @return The maximum height that the \c cusp can raise the hypercube
     *          generated by \c point to. If no upward movement is possible,
     *          then a negative number is returned (probably -1).
     */
    float_type operator()
        ( const point_type& __point, const cusp_type& __cusp )
    {
      // Set the member variables
      point_ = &( __point );
      cpoint_ = &( __cusp.point() );
      threshold_ = __cusp.threshold();
      
      // Compute phi.
      sys_compute();
      
      return float_type( phi_ );
    }
    
    
    /**
     *  @brief  The maximum height that a given hypercube can be raised to with
     *          a cusp of a given threshold.
     *  @param  point The first vertex of a hypercube.
     *  @param  threshold The threshold of a cusp.
     */
    float_type threshold_height
        ( const point_type& __point, param_type __threshold )
    {
      point_type midpoint( sys_midpoint( __point ) );
      
      point_ = &( __point );
      // The midpoint takes the place of a cusp
      cpoint_ = &( midpoint );
      threshold_ = __threshold;
      
      // Compute phi.
      sys_compute();
      
      return float_type( phi_ );
    }
    
    
  private:
    /**
     *  @brief  Compute the phi function, on the current data members
     */
    void sys_compute ( void ) {
      // Initialise the functor
      ff_pair_type ffp = sys_initialize( );
      
      // Compute the minimum over all vertices
      float_type phi = 0.0;
      if( sys_imag( ffp.second, phi ) && sys_real( ffp.first, phi ) ) {
        for( std::size_t i = 0; i != point_type::heisenberg_size; ++i ) {
          if( !sys_compute_vertices( i, ffp.first, ffp.second ) ) {
            break;
          }
        }
      }
    }
    
    
    /**
     *  @brief  Compute the inital values for the real and imaginary parts.
     *  @return A pair, where the first element is the real component and the
     *          second is the imaginary component.
     */
    ff_pair_type sys_initialize( void )
    {
      using utility::math::hermitian_inner_product;
      complex_type hip
          = hermitian_inner_product( point_->zeta_ref_begin(),
                                     point_->zeta_ref_end(),
                                     cpoint_->zeta_ref_begin()
                                   );
      
      phi_ = 2.0;
      return ff_pair_type(   hip.real()
                           + point_->dependent().real_ref()
                           + point_->height_ref() * 0.5
                           + cpoint_->dependent().real_ref() ,
                          point_->r_common() - cpoint_->r_common() + hip.imag()
                         );
    }
    
    
    /**
     *  @brief  The main function which computes the maximum height at each
     *          vertex.
     *  @param  loc The index of the coordinate of the vertex to change.
     *  @param  re The real component of the vertex where this coordinate is
     *          not modified.
     *  @param  im The imaginary component of the vertex where this coordinate
     *          is not modified.
     *  @return True if upward movement is possible, false otherwise.
     */
    bool sys_compute_vertices
        ( std::size_t __loc, float_type __re, float_type __im )
    {
      bool b = false;
      float_type phi = 0.0;
      
      if( __loc != point_type::zeta_real_size ) {
        __im += sys_zeta_imag( __loc );
        if( !sys_imag( __im, phi ) ) {
          return b;
        }
        
        __re += sys_zeta_real( __loc );
        if( !sys_real( __re, phi ) ) {
          return b;
        }
        
        // At this stage loop through all remaining vertices and recursively call
        // this function. Ideally I would prefer not to use recursion, but it is
        // definitely the most natural way of doing things.
        for( ++__loc; __loc != point_type::heisenberg_size; ++__loc ) {
          if( !sys_compute_vertices( __loc, __re, __im ) ) {
            return b;
          }
        }
      }
      else {
        __im += sys_r_imag();
        if( !sys_imag( __im, phi ) ) {
          return b;
        }
        
        if( !sys_real( __re, phi ) ) {
          return b;
        }
      }
      
      b = true;
      return b;
    }
    
    
    /**
     *  @brief  Modify the imaginary component when a zeta coordinate changes.
     *  @param  loc The common index of the zeta coordinate.
     *  @return The amount by which to modify the imaginary component.
     */
    float_type sys_zeta_imag ( std::size_t __loc ) {
      return float_type(   __loc % 2 == 0
                         ?   static_cast<float_type>(
                               -slice_->forward().real_ref_at(__loc/2).stride()
                               * cpoint_->common_at(__loc + 1)
                             )
                         :   static_cast<float_type>(
                               slice_->forward().imag_ref_at(__loc/2).stride()
                               * cpoint_->common_at(__loc - 1)
                             )
                       );
    }
    
    
    /**
     *  @brief  Modify the imaginary component when a r coordinate changes.
     *  @return The amount by which to modify the imaginary component.
     */
    float_type sys_r_imag ( void ) {
      return float_type( slice_->forward().r_ref().stride() );
    }
    
    
    /**
     *  @brief  Compute the amount attributable to the imaginary component.
     *  @param  im The basic imaginary value.
     *  @param  phi A reference to the value to output.
     *  @return False if at this stage no upward movement is possible.
     */
    bool sys_imag( param_type __im, float_type& __phi ) {
      typedef utility::math::is_zero<float_type> _iz;
      bool b = true;
      
      __phi = __im * __im;
      __phi = threshold_ - __phi;
      
      if( __phi < 0.0 ) {
        phi_ = fail_;
        b = false;
      }
      else {
        __phi = ::sqrt( __phi );
      }
      
      
      
      return b;
    }
    
    
    /**
     *  @brief  Modify the real component when a zeta coordinate changes.
     *  @param  loc The common index of the zeta coordinate.
     *  @return The amount by which to modify the real component.
     */
    float_type sys_zeta_real( std::size_t __loc ) {
      float_type real = 0.0;
      if( __loc % 2 == 0 ) {
        real =  slice_->forward().real_ref_at(__loc/2).stride()
               * cpoint_->common_at(__loc)
               + slice_->forward().real_ref_at(__loc/2).dependent(
                   point_->common_at( __loc )
                 );
      }
      else {
        real =  slice_->forward().imag_ref_at(__loc/2).stride()
               * cpoint_->common_at(__loc)
               + slice_->forward().imag_ref_at(__loc/2).dependent(
                   point_->common_at( __loc )
                 );
      }
      
      return real;
    }
    
    
    /**
     *  @brief  Compute total phi function and update the global minimum.
     *  @param  re The basic real value.
     *  @param  phi the value attributable to the imaginary component.
     *  @return False if no upward movement is possible.
     */
    bool sys_real ( param_type __re, float_type __phi )
    {
      typedef utility::math::is_zero<float_type> _iz;
      bool b = true;
      __phi += __re;
      __phi *= 2.0;
      
      if( __phi < 0.0 || _iz()( __phi ) ) {
        phi_ = fail_;
        b = false;
      }
      else if ( __phi < phi_ ) {
        phi_ = __phi;
      }
      
      return b;
    }
    
    
    /**
     *  @brief  Compute the midpoint of a hypercube generated by a vertex.
     *  @param  point The first vertex of the hypercube.
     *  @return The midpoint of a hypercube with \c point as its first vertex,
     *          as determined by the \c slice.
     */
    point_type sys_midpoint( const point_type& __point ) const {
      typedef typename point_type::iterator pt_iter;
      typedef typename slice_type::const_iterator sl_iter;
      
      // Naievely add half the stride to each vertex and initialise.
      point_type midpoint( __point );
      pt_iter pit = midpoint.begin();
      sl_iter sit = slice_->begin();
      for( ; pit != midpoint.heisenberg_end(); ++pit, ++sit ) {
        *pit += 0.5 * ( sit->stride() );
      }
      
      midpoint.initialize();
      return midpoint;
    }
    
    
    static const float_type fail_;
    //! The slice governing the discretisation of the space
    const slice_type* slice_;
    //! A pointer to the cusp point
    const point_type* cpoint_;
    //! A pointer to the cusp point
    const point_type* point_;
    //! The threshold
    float_type threshold_;
    //! The phi output value
    float_type phi_;
};


// Initialise the static constant member
template <class P, class S, class C>
    const typename C::float_type point_phi<P,S,C>::fail_(-1.0);


}// effect
}// geometry
}// sg
#endif
